%% Flap Sizing Program
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%performs flap sizing based on Young, A.D., "The Aerodynamic Characteristics of Flaps", Aeronautical Research Council Reports and
%Memoranda, R&M 2622, 1953.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%
%first input a target CL, CL generated by wing, flap span ratio b_f/b
%program varies flap deflection to find chord ratio 
%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%
%ASSUMPTIONS
%currently assumes TO speed to be 1.2x of stall speed, which is assumed at
%CL MAX

%THIS CAN BE REFINED WITH A TAKEOFF MODEL
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%
%UPDATES TO BE MADE
%automatically obtain CL generated by wing based on speed, altitude, alpha
%by using MainFunction.m and developing takeoff model
%%%%%%%%%%%%%%%%%%%%%%%%%%

%housekeeping 
clc; clear; close all;

%importing constants from excel sheet
% Import data file
DragBuildUp = importfileTEST('DragBuildUp.xlsx');
% Take individual variables from excel sheet
for i=1:14      %Plane property section
    assignin('base',DragBuildUp{i,2},DragBuildUp{i,3});
end

%inputting required values

%stall speed 76.43 kts
%approach speed 148.42 ft/s 
V_ = ;                %in knots
q = 0.5 * 0.002378 * V_TO^2;    %takeoff dynamic pressure at sea level
CL_W = W/(q*S);                 %input CL generated by the wing at conditions
CL_target = 2.0;                %input targeted CL for wing and flaps combination

deltaCL = CL_target - 0.9*CL_W;
bf_b = 0.55;                    %input ratio of flap span to wing span



%% analysis section (interpolating data, solving for chord ratio

deflection_start = 0;       %degrees
deflection_end = 80;        %degrees
deflection_interval = 10;   %degrees

deflections = deflection_start:deflection_interval:deflection_end;
init_arr = zeros(length(deflections),1);
[lambda1, lambda2, lambda22, lambda3, delta1, delta2, delta3, K, mu1, mu2] = deal(init_arr);

                      %iterator index
for j=1:length(deflections)





end



%% functions

function [delta2] = delta2fun(deflection)
%
    % Import data sets
    data = importfile("drag_tail_delta1.csv"); % Call function to get first data set
    

    % Extract x and y data from the first data set
    % Assume data1 has four columns: x, y for curve 1, y for curve 2, y for curve 3
    x1 = data1(:, 1); % First column is x data
    y1_1 = data1(:, 2); % Second column is y data for curve 1
    y1_2 = data1(:, 3); % Third column is y data for curve 2
    y1_3 = data1(:, 4); % Fourth column is y data for curve 3

    % Extract x and y data from the second data set
    % Assume data2 has four columns: x, y for curve 1, y for curve 2, y for curve 3
    x2 = data2(:, 1); % First column is x data
    y2_1 = data2(:, 2); % Second column is y data for curve 1
    y2_2 = data2(:, 3); % Third column is y data for curve 2
    y2_3 = data2(:, 4); % Fourth column is y data for curve 3

    % Perform interpolation for the first data set using C_LT as the query point
    y1_1_interp = interp1(x1, y1_1, cf_C, 'linear', 'extrap');
    y1_2_interp = interp1(x1, y1_2, cf_C, 'linear', 'extrap');
    y1_3_interp = interp1(x1, y1_3, cf_C, 'linear', 'extrap');

    % Linearly interpolate between the three curves based on t_c

    if t_c >=0.12 && t_c<=0.21
        % Interpolate between curve 1 and curve 2
        tail_delta1 = y1_1_interp + (y1_2_interp - y1_1_interp) * t_c / 0.5;
    elseif t_c<0.12 || t_c >0.3
        error("t/c must be between 0.12 and 0.3");
    else
        % Interpolate between curve 2 and curve 3
        tail_delta1 = y1_2_interp + (y1_3_interp - y1_2_interp) * (t_c - 0.5) / 0.5;
    end

    % Perform interpolation for the second data set using A_T as the query point
    y2_1_interp = interp1(x2, y2_1, beta, 'linear', 'extrap');
    y2_2_interp = interp1(x2, y2_2, beta, 'linear', 'extrap');
    y2_3_interp = interp1(x2, y2_3, beta, 'linear', 'extrap');

    % Linearly interpolate between the three curves based on t_c
    if t_c <= 0.3 && t_c>=0.21
        % Interpolate between curve 1 and curve 2
        tail_delta2 = y2_1_interp + (y2_2_interp - y2_1_interp) * t_c / 0.5;
    elseif t_c<0.12 || t_c > 0.3
        error("t/c must be between 0.12 and 0.3")
    else
        % Interpolate between curve 2 and curve 3
        tail_delta2 = y2_2_interp + (y2_3_interp - y2_2_interp) * (t_c - 0.5) / 0.5;
    end

    % Output the interpolated results
    % You can manually define the final output using tail_delta1 and tail_delta2
    C_DiT = ((C_LT^2) / (pi * A_T)) * (1+tail_delta1+tail_delta2) * (S_T/S); %induced drag of the horizontal tail
end

